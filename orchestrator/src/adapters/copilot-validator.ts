/**
 * Copilot Code Validator
 * 
 * Validates code generated by GitHub Copilot against the same
 * constraint systems used by the AI Orchestrator.
 * 
 * This enables both workflows to maintain consistent quality:
 * - Orchestrator: Automated code generation with validation
 * - Copilot: Interactive code generation with validation
 */

import * as fs from 'fs/promises';
import * as path from 'path';
import { Logger } from '@utils/logger';

export interface ValidationResult {
  passed: boolean;
  errors: ValidationError[];
  warnings: ValidationWarning[];
  metrics: {
    lighthouse?: number;
    coverage?: number;
    vulnerabilities?: number;
    typeErrors?: number;
  };
  timestamp: Date;
}

export interface ValidationError {
  category: 'performance' | 'security' | 'accessibility' | 'types' | 'tests';
  severity: 'critical' | 'high' | 'medium' | 'low';
  message: string;
  file?: string;
  line?: number;
  suggestion: string;
}

export interface ValidationWarning {
  category: string;
  message: string;
  file?: string;
  suggestion: string;
}

/**
 * Main validator class
 */
export class CopilotCodeValidator {
  private logger: Logger;
  private workspaceRoot: string;

  constructor(workspaceRoot: string = process.cwd()) {
    this.logger = new Logger('CopilotValidator');
    this.workspaceRoot = workspaceRoot;
  }

  /**
   * Validate all generated code
   */
  async validateGeneratedCode(files: GeneratedFile[]): Promise<ValidationResult> {
    this.logger.info('Starting code validation...', { fileCount: files.length });

    const errors: ValidationError[] = [];
    const warnings: ValidationWarning[] = [];
    const metrics = {
      lighthouse: 0,
      coverage: 0,
      vulnerabilities: 0,
      typeErrors: 0,
    };

    try {
      // 1. Validate TypeScript
      const tsErrors = await this.validateTypeScript(files);
      errors.push(...tsErrors);
      metrics.typeErrors = tsErrors.length;

      // 2. Validate Performance
      const perfErrors = await this.validatePerformance(files);
      errors.push(...perfErrors);

      // 3. Validate Security
      const secErrors = await this.validateSecurity(files);
      errors.push(...secErrors);
      metrics.vulnerabilities = secErrors.length;

      // 4. Validate Accessibility
      const a11yErrors = await this.validateAccessibility(files);
      errors.push(...a11yErrors);

      // 5. Validate Tests
      const testErrors = await this.validateTests(files);
      errors.push(...testErrors);

      // 6. Validate File Structure
      const structErrors = await this.validateFileStructure(files);
      errors.push(...structErrors);

      const passed = errors.filter(e => e.severity === 'critical').length === 0;

      return {
        passed,
        errors,
        warnings,
        metrics,
        timestamp: new Date(),
      };
    } catch (error) {
      this.logger.error('Validation failed', { error });
      throw error;
    }
  }

  /**
   * Validate TypeScript compilation
   */
  private async validateTypeScript(files: GeneratedFile[]): Promise<ValidationError[]> {
    const errors: ValidationError[] = [];

    const tsFiles = files.filter(f => f.path.endsWith('.ts') || f.path.endsWith('.tsx'));

    if (tsFiles.length === 0) {
      return errors;
    }

    this.logger.info('Checking TypeScript...', { fileCount: tsFiles.length });

    // Check for common TypeScript issues
    for (const file of tsFiles) {
      const content = file.content;

      // Check for 'any' type
      if (content.includes(': any')) {
        errors.push({
          category: 'types',
          severity: 'high',
          message: 'Using "any" type reduces type safety',
          file: file.path,
          suggestion: 'Replace "any" with specific types. Example: "Record<string, string>" instead of "any"',
        });
      }

      // Check for missing imports
      if (content.includes('React.FC') && !content.includes('import React')) {
        errors.push({
          category: 'types',
          severity: 'critical',
          message: 'React imported but not declared',
          file: file.path,
          suggestion: 'Add: import React from "react";',
        });
      }

      // Check for missing error handling
      if (content.includes('await') && !content.includes('try') && !content.includes('?')) {
        errors.push({
          category: 'types',
          severity: 'medium',
          message: 'Async/await without error handling',
          file: file.path,
          suggestion: 'Wrap async calls in try/catch or use .catch() chain',
        });
      }

      // Check for console.log in production code (not tests)
      if (!file.path.includes('test') && content.includes('console.log')) {
        errors.push({
          category: 'types',
          severity: 'medium',
          message: 'console.log found in production code',
          file: file.path,
          suggestion: 'Replace with proper logger: logger.info() or remove',
        });
      }
    }

    return errors;
  }

  /**
   * Validate Performance Constraints
   */
  private async validatePerformance(files: GeneratedFile[]): Promise<ValidationError[]> {
    const errors: ValidationError[] = [];

    this.logger.info('Checking Performance constraints...');

    const frontendFiles = files.filter(
      f => f.path.includes('frontend/') && (f.path.endsWith('.tsx') || f.path.endsWith('.ts'))
    );

    for (const file of frontendFiles) {
      const content = file.content;

      // Check for unoptimized images
      if (content.includes('<img') && !content.includes('Image from') && !content.includes('next/image')) {
        errors.push({
          category: 'performance',
          severity: 'high',
          message: 'HTML img tag used instead of Next.js Image component',
          file: file.path,
          suggestion: 'Import and use: import Image from "next/image"; then use <Image /> with optimization',
        });
      }

      // Check for missing lazy loading
      if (content.includes('Map') && !content.includes('lazy')) {
        errors.push({
          category: 'performance',
          severity: 'high',
          message: 'Large component not code-split',
          file: file.path,
          suggestion: 'Use dynamic import: const Component = dynamic(() => import(...), { loading: () => <div>Loading...</div> })',
        });
      }

      // Check for missing memoization
      if (content.includes('useCallback') && content.includes('[]')) {
        errors.push({
          category: 'performance',
          severity: 'medium',
          message: 'useCallback with empty dependency array may cause stale closures',
          file: file.path,
          suggestion: 'Verify dependency array is correct or consider useRef',
        });
      }

      // Check for unoptimized re-renders
      if (content.includes('useState') && content.includes('setState') && !content.includes('useCallback')) {
        errors.push({
          category: 'performance',
          severity: 'medium',
          message: 'Frequent state updates without memoization optimization',
          file: file.path,
          suggestion: 'Consider useMemo or useCallback to prevent unnecessary re-renders',
        });
      }
    }

    // Check backend performance
    const backendFiles = files.filter(
      f => f.path.includes('backend/') && f.path.endsWith('.ts')
    );

    for (const file of backendFiles) {
      const content = file.content;

      // Check for N+1 queries
      if (content.includes('for') && content.includes('findOne') && !content.includes('findMany')) {
        errors.push({
          category: 'performance',
          severity: 'high',
          message: 'Potential N+1 database query pattern',
          file: file.path,
          suggestion: 'Use prisma.findMany() with include/select or batch query instead of loop',
        });
      }

      // Check for missing indexes
      if (content.includes('where:') && !file.path.includes('migration')) {
        // This is a heuristic - actual check would be in DB schema
      }

      // Check for synchronous operations
      if (content.includes('execSync') || content.includes('readFileSync')) {
        errors.push({
          category: 'performance',
          severity: 'high',
          message: 'Synchronous operation blocks event loop',
          file: file.path,
          suggestion: 'Use async version: execFile, readFile, etc.',
        });
      }
    }

    return errors;
  }

  /**
   * Validate Security Constraints
   */
  private async validateSecurity(files: GeneratedFile[]): Promise<ValidationError[]> {
    const errors: ValidationError[] = [];

    this.logger.info('Checking Security constraints...');

    for (const file of files) {
      const content = file.content;

      // Check for hardcoded secrets
      if (content.match(/api[_-]?key\s*[:=]\s*['"][a-zA-Z0-9]{20,}/i)) {
        errors.push({
          category: 'security',
          severity: 'critical',
          message: 'Hardcoded API key detected',
          file: file.path,
          suggestion: 'Move to environment variables: process.env.API_KEY',
        });
      }

      // Check for SQL injection
      if (content.includes('query(') && !content.includes('$') && file.path.includes('backend')) {
        errors.push({
          category: 'security',
          severity: 'critical',
          message: 'Potential SQL injection vulnerability',
          file: file.path,
          suggestion: 'Use parameterized queries with $ placeholders or use Prisma ORM',
        });
      }

      // Check for XSS vulnerabilities
      if (content.includes('dangerouslySetInnerHTML')) {
        errors.push({
          category: 'security',
          severity: 'high',
          message: 'dangerouslySetInnerHTML creates XSS vulnerability',
          file: file.path,
          suggestion: 'Sanitize HTML with DOMPurify before rendering, or use safer alternatives',
        });
      }

      // Check for insecure crypto
      if (content.includes('crypto.randomBytes(8)') || content.match(/randomBytes\(\s*[0-9]\s*\)/)) {
        errors.push({
          category: 'security',
          severity: 'high',
          message: 'Insufficient randomness for cryptographic token',
          file: file.path,
          suggestion: 'Use at least 32 bytes: crypto.randomBytes(32)',
        });
      }

      // Check for missing CORS
      if (content.includes('Express') && !content.includes('cors') && !content.includes('CORS')) {
        errors.push({
          category: 'security',
          severity: 'medium',
          message: 'CORS configuration may be missing',
          file: file.path,
          suggestion: 'Add cors middleware: app.use(cors({ origin: process.env.ALLOWED_ORIGINS }))',
        });
      }

      // Check for missing input validation
      if (content.includes('req.body') && !content.includes('validate') && !content.includes('schema')) {
        errors.push({
          category: 'security',
          severity: 'high',
          message: 'Request body not validated',
          file: file.path,
          suggestion: 'Add validation: const validated = createSchema.parse(req.body)',
        });
      }

      // Check for missing authentication
      if (content.includes('/api/') && !content.includes('auth') && !content.includes('isPublic')) {
        errors.push({
          category: 'security',
          severity: 'high',
          message: 'API endpoint may not have authentication',
          file: file.path,
          suggestion: 'Add authentication check: @IsAuthenticated() or similar',
        });
      }
    }

    return errors;
  }

  /**
   * Validate Accessibility Constraints (WCAG 2.1 AA)
   */
  private async validateAccessibility(files: GeneratedFile[]): Promise<ValidationError[]> {
    const errors: ValidationError[] = [];

    this.logger.info('Checking Accessibility (WCAG 2.1 AA)...');

    const frontendFiles = files.filter(
      f => f.path.includes('frontend/') && f.path.endsWith('.tsx')
    );

    for (const file of frontendFiles) {
      const content = file.content;

      // Check for alt text on images
      if (content.includes('img') && !content.includes('alt=')) {
        errors.push({
          category: 'accessibility',
          severity: 'high',
          message: 'Image missing alt text',
          file: file.path,
          suggestion: 'Add alt attribute: <img alt="description of image" />',
        });
      }

      // Check for form labels
      if (content.includes('<input') && !content.includes('<label')) {
        errors.push({
          category: 'accessibility',
          severity: 'high',
          message: 'Form input missing associated label',
          file: file.path,
          suggestion: 'Add: <label htmlFor="inputId">Label</label> <input id="inputId" />',
        });
      }

      // Check for semantic HTML
      if (content.includes('<div') && content.includes('button')) {
        errors.push({
          category: 'accessibility',
          severity: 'medium',
          message: 'Using div for interactive elements instead of semantic HTML',
          file: file.path,
          suggestion: 'Use semantic elements: <button>, <nav>, <main>, <section>, etc.',
        });
      }

      // Check for color contrast
      if (!file.path.includes('test') && content.match(/#[0-9A-Fa-f]{6}/)) {
        // This is a heuristic - real check needs contrast calculation
        errors.push({
          category: 'accessibility',
          severity: 'medium',
          message: 'Verify color contrast meets WCAG AA (4.5:1 for text)',
          file: file.path,
          suggestion: 'Use contrast checker: https://webaim.org/resources/contrastchecker/',
        });
      }

      // Check for aria labels
      if (content.includes('icon') && !content.includes('aria-label')) {
        errors.push({
          category: 'accessibility',
          severity: 'medium',
          message: 'Icon button missing aria-label',
          file: file.path,
          suggestion: 'Add: <button aria-label="description">Icon</button>',
        });
      }

      // Check for heading hierarchy
      if (content.includes('<h3') && !content.includes('<h1') && !content.includes('<h2')) {
        errors.push({
          category: 'accessibility',
          severity: 'medium',
          message: 'Heading hierarchy broken (h3 without h1/h2)',
          file: file.path,
          suggestion: 'Use proper heading order: h1 → h2 → h3',
        });
      }
    }

    return errors;
  }

  /**
   * Validate Test Coverage
   */
  private async validateTests(files: GeneratedFile[]): Promise<ValidationError[]> {
    const errors: ValidationError[] = [];

    this.logger.info('Checking Test Coverage...');

    const testFiles = files.filter(f => f.path.includes('.test.') || f.path.includes('.spec.'));
    const sourceFiles = files.filter(f => !f.path.includes('.test.') && !f.path.includes('.spec.'));

    if (testFiles.length === 0) {
      errors.push({
        category: 'tests',
        severity: 'high',
        message: 'No test files generated',
        suggestion: 'Generate test files for all components and functions. Target 80%+ coverage.',
      });
    }

    if (testFiles.length > 0 && sourceFiles.length > 0) {
      const testRatio = testFiles.length / sourceFiles.length;
      if (testRatio < 0.5) {
        errors.push({
          category: 'tests',
          severity: 'medium',
          message: `Low test-to-code ratio: ${testRatio.toFixed(2)}:1`,
          suggestion: 'Add more test files. Aim for at least 1 test file per source file.',
        });
      }
    }

    // Check for test quality
    for (const file of testFiles) {
      const content = file.content;

      if (!content.includes('describe')) {
        errors.push({
          category: 'tests',
          severity: 'medium',
          message: 'Test file missing describe blocks',
          file: file.path,
          suggestion: 'Organize tests with describe: describe("ComponentName", () => { ... })',
        });
      }

      if (!content.includes('it(') && !content.includes('test(')) {
        errors.push({
          category: 'tests',
          severity: 'medium',
          message: 'Test file has no test cases',
          file: file.path,
          suggestion: 'Add test cases: it("should do something", () => { ... })',
        });
      }

      if (!content.includes('expect')) {
        errors.push({
          category: 'tests',
          severity: 'high',
          message: 'Test cases missing assertions',
          file: file.path,
          suggestion: 'Add assertions: expect(result).toBe(expected)',
        });
      }

      // Check for error paths
      if (!content.includes('throw') && !content.includes('error') && !content.includes('catch')) {
        errors.push({
          category: 'tests',
          severity: 'medium',
          message: 'Tests missing error/exception cases',
          file: file.path,
          suggestion: 'Add tests for error conditions and edge cases',
        });
      }
    }

    return errors;
  }

  /**
   * Validate File Structure
   */
  private async validateFileStructure(files: GeneratedFile[]): Promise<ValidationError[]> {
    const errors: ValidationError[] = [];

    this.logger.info('Checking File Structure...');

    const missingComponents = {
      frontend: {
        hasComponents: false,
        hasTests: false,
        hasHooks: false,
        hasTypes: false,
      },
      backend: {
        hasControllers: false,
        hasServices: false,
        hasTests: false,
        hasTypes: false,
      },
    };

    for (const file of files) {
      if (file.path.includes('frontend/src/components/')) missingComponents.frontend.hasComponents = true;
      if (file.path.includes('frontend/src/hooks/')) missingComponents.frontend.hasHooks = true;
      if (file.path.includes('frontend/src/types/')) missingComponents.frontend.hasTypes = true;
      if (file.path.includes('frontend/') && file.path.includes('.test.')) missingComponents.frontend.hasTests = true;

      if (file.path.includes('backend/src/api/') && file.path.includes('controller')) missingComponents.backend.hasControllers = true;
      if (file.path.includes('backend/src/api/') && file.path.includes('service')) missingComponents.backend.hasServices = true;
      if (file.path.includes('backend/') && file.path.includes('.test.')) missingComponents.backend.hasTests = true;
      if (file.path.includes('backend/src/types/')) missingComponents.backend.hasTypes = true;
    }

    // Check frontend structure
    if (files.some(f => f.path.includes('frontend/'))) {
      if (!missingComponents.frontend.hasComponents) {
        errors.push({
          category: 'types',
          severity: 'high',
          message: 'Frontend components missing',
          suggestion: 'Create components in frontend/src/components/',
        });
      }
      if (!missingComponents.frontend.hasTypes) {
        errors.push({
          category: 'types',
          severity: 'medium',
          message: 'Frontend types missing',
          suggestion: 'Create types in frontend/src/types/',
        });
      }
      if (!missingComponents.frontend.hasTests) {
        errors.push({
          category: 'tests',
          severity: 'high',
          message: 'Frontend tests missing',
          suggestion: 'Create test files in frontend/src/**/__tests__/',
        });
      }
    }

    // Check backend structure
    if (files.some(f => f.path.includes('backend/'))) {
      if (!missingComponents.backend.hasControllers) {
        errors.push({
          category: 'types',
          severity: 'high',
          message: 'Backend controllers missing',
          suggestion: 'Create controllers in backend/src/api/[feature]/controller.ts',
        });
      }
      if (!missingComponents.backend.hasServices) {
        errors.push({
          category: 'types',
          severity: 'high',
          message: 'Backend services missing',
          suggestion: 'Create services in backend/src/api/[feature]/service.ts',
        });
      }
      if (!missingComponents.backend.hasTests) {
        errors.push({
          category: 'tests',
          severity: 'high',
          message: 'Backend tests missing',
          suggestion: 'Create test files in backend/src/**/__tests__/',
        });
      }
    }

    return errors;
  }

  /**
   * Generate validation report
   */
  generateReport(result: ValidationResult): string {
    const report = [
      '\n╔═══════════════════════════════════════════════════════╗',
      '║            COPILOT CODE VALIDATION REPORT             ║',
      '╚═══════════════════════════════════════════════════════╝\n',
      `Status: ${result.passed ? '✅ PASSED' : '❌ FAILED'}`,
      `Timestamp: ${result.timestamp.toISOString()}\n`,
      `Errors: ${result.errors.length}`,
      `Warnings: ${result.warnings.length}\n`,
      'Metrics:',
      `  Type Errors: ${result.metrics.typeErrors}`,
      `  Vulnerabilities: ${result.metrics.vulnerabilities}`,
      `  Coverage: ${result.metrics.coverage}%`,
      `  Lighthouse: ${result.metrics.lighthouse}/100\n`,
    ];

    if (result.errors.length > 0) {
      report.push('❌ CRITICAL ERRORS:\n');
      const criticalErrors = result.errors.filter(e => e.severity === 'critical');
      for (const error of criticalErrors) {
        report.push(`  • [${error.category.toUpperCase()}] ${error.message}`);
        if (error.file) report.push(`    File: ${error.file}`);
        report.push(`    Fix: ${error.suggestion}\n`);
      }
    }

    if (result.errors.length > 0) {
      report.push('⚠️  WARNINGS:\n');
      const other = result.errors.filter(e => e.severity !== 'critical');
      for (const error of other.slice(0, 5)) {
        report.push(`  • [${error.category.toUpperCase()}] ${error.message}`);
        report.push(`    Fix: ${error.suggestion}\n`);
      }
      if (other.length > 5) {
        report.push(`  ... and ${other.length - 5} more warnings\n`);
      }
    }

    report.push('═══════════════════════════════════════════════════════\n');

    return report.join('\n');
  }
}

/**
 * Generated file interface
 */
export interface GeneratedFile {
  path: string;
  content: string;
  language: 'typescript' | 'javascript' | 'json' | 'sql' | 'css';
}

// Export for CLI usage
if (require.main === module) {
  (async () => {
    const validator = new CopilotCodeValidator();
    console.log('Copilot Code Validator ready');
    console.log('Usage: validator.validateGeneratedCode(files)');
  })();
}
